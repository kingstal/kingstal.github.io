---
layout: post
title: iOS就业
category: 技术
tags: iOS就业
keywords: iOS就业
description: iOS就业
---

### MRC

- 手写Set方法

```objc
- (void)setName:(NSString *)name
{
    if (_name != name)
    {
        [_name release]; // relese旧值
        _name = [name retain]; // retain新值
    }
}
```


### UIImage的内存问题

```objc
// imageNamed: 有缓存(传入文件名)
//        UIImage *image = [UIImage imageNamed:filename];

// imageWithContentsOfFile: 没有缓存(传入文件的全路径)
NSBundle *bundle = [NSBundle mainBundle];
NSString *path = [bundle pathForResource:filename ofType:nil];
UIImage *image = [UIImage imageWithContentsOfFile:path];
```

### UIImageView帧动画

```objc
if (self.tom.isAnimating) return;

// 1.加载所有的动画图片
NSMutableArray *images = [NSMutableArray array];

for (int i = 0; i<count; i++) {
    // 计算文件名
    NSString *filename = [NSString stringWithFormat:@"%@_%02d.jpg", name, i];
    // 加载图片
    NSBundle *bundle = [NSBundle mainBundle];
    NSString *path = [bundle pathForResource:filename ofType:nil];
    UIImage *image = [UIImage imageWithContentsOfFile:path];

    // 添加图片到数组中
    [images addObject:image];
}
self.tom.animationImages = images;

// 2.设置播放次数(1次)
self.tom.animationRepeatCount = 1;

// 3.设置播放时间
self.tom.animationDuration = images.count * 0.05;

[self.tom startAnimating];

// 4.动画放完1秒后清除内存
CGFloat delay = self.tom.animationDuration + 1.0;
[self.tom performSelector:@selector(setAnimationImages:) withObject:nil afterDelay:delay];
```

### Xib文件的加载

- 方法1
`NSArray *objs = [[NSBundle mainBundle] loadNibNamed:@"MJAppView" owner:nil options:nil];`
这个方法会创建xib中的所有对象，并且将对象按顺序放到objs数组中

- 方法2
bundle参数可以为nil，默认就是main bundle
`UINib *nib = [UINib nibWithNibName:@"MJAppView" bundle:[NSBundle mainBundle]];`
`NSArray *objs = [nib instantiateWithOwner:nil options:nil];`


### 控制状态栏的样式

- iOS 7 之前在`AppDelegate`中修改

```objc
[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];
```

- iOS 7

```objc
- (UIStatusBarStyle)preferredStatusBarStyle
{
    return UIStatusBarStyleLightContent;
}
```

### UIScrollView

> `@property(nonatomic) CGSize contentSize;`
表示UIScrollView内容的尺寸，滚动范围(能滚多远)

> `@property(nonatomic) CGPoint contentOffset;`
表示UIScrollView滚动的位置

> `@property(nonatomic) UIEdgeInsets contentInset;`
在UIScrollView的4周增加额外的滚动区域(外边距)

![UIScrollView](/assets/image/iOS就业-UIScrollView.png)


通过设置`UIScrollView`的`id<UISCrollViewDelegate> delegate`代理对象实现：

- 滚动
`- (void)scrollViewDidScroll:(UIScrollView * nonnull)scrollView`

- 缩放
1. 设置`minimumZoomScale` ：缩小的最小比例
2. 设置`maximumZoomScale` ：放大的最大比例
3. 让代理对象实现下面的方法，返回需要缩放的视图控件`- (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView;`


`UIScrollView`分页和`UIPageControl`
1. 根据scrollView的`frame`来确定分页宽度：`scrollView.pagingEnabled = YES`
2. `UIPageControl`：`@property(nonatomic) NSInteger currentPage`     `@property(nonatomic) NSInteger numberOfPages`

### 定时器 NSTimer

```objc
// 另一种+ (NSTimer * nonnull)timerWithTimeInterval:(NSTimeInterval)seconds invocation:(NSInvocation * nonnull)invocation repeats:(BOOL)repeats
// 需要手动启动 - (void)fire
self.timer = [NSTimer timerWithTimeInterval:1.5 target:self selector:@selector(nextImage) userInfo:nil repeats:YES];

// 注册定时器到RunLoop
[[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];

// 删除定时器
[self.timer invalidate]; // 定时器一旦停止就不能再使用
self.timer = nil;
```

### UITableView

- `UITableViewCell`的重要属性：

> `@property(nonatomic) UITableViewCellAccessoryType accessoryType`
> `@property(nonatomic, strong) UIView *accessoryView`
> `@property(nonatomic, strong) UIView *backgroundView` 不用设置尺寸，优先级>backgroundColor
> `@property(nonatomic, strong) UIView *selectedBackgroundView`

- `UITableView`的重要属性：

> `@property(nonatomic) UITableViewCellSeparatorStyle separatorStyle`
> `@property(nonatomic, strong) UIColor *separatorColor`
> `@property(nonatomic, strong) UIView *tableHeaderView`
> `@property(nonatomic, strong) UIView *tableFooterView` 宽度是tableView的宽度

- `UITableViewDataSource`的方法

> `- (NSArray<NSString *> * nullable)sectionIndexTitlesForTableView:(UITableView * nonnull)tableView` 返回字符串数组作为`tableView`右侧的索引条
>


### 使用xib封装一个view的步骤
1. 新建一个xib文件描述一个view的内部结构(假设叫做`MJTgCell.xib`)
2. 新建一个自定义的类
(自定义类需要继承自系统自带的`view`, 继承自哪个类,  取决于`xib`根对象的Class)
3. 新建类的类名最好跟``xib``的文件名保持一致(比如类名就叫做`MJTgCell`)
4. 将`xib`中的控件和自定义类的`.m文件` 进行连线
5. 提供一个类方法返回一个创建好的自定义view(屏蔽从`xib`加载的过程)
6. 提供一个模型属性让外界传递模型数据
7. 重写模型属性的`setter方法`,在这里将模型数据展示到对应的子控件上面

### 通过代码自定义cell(cell的高度不一致)

1. 新建一个继承自`UITableViewCell`的类
2. 重写`initWithStyle:reuseIdentifier:`方法

> 添加所有需要显示的子控件(不需要设置子控件的数据和frame,  子控件要添加到`contentView`中)
进行子控件一次性的属性设置(有些属性只需要设置一次, 比如字体\固定的图片)

3. 提供2个模型
数据模型: 存放文字数据\图片数据
`frame模型`: 存放数据模型\所有子控件的frame\cell的高度 (提供数据模型的`setter`方法，在其中计算控件的frame和cell的高度)
4. cell拥有一个frame模型(不要直接拥有数据模型)
5. 重写`frame模型`属性的setter方法: 在这个方法中设置子控件的显示数据和`frame`
6. `frame模型`数据的初始化已经采取懒加载的方式(每一个cell对应的frame模型数据只加载一次)

### 计算文字尺寸

> `- boundingRectWithSize:options:attributes:context:`

```objc
/**
 *  计算文字尺寸
 *
 *  @param text    需要计算尺寸的文字
 *  @param font    文字的字体
 *  @param maxSize 文字的最大尺寸
 */
- (CGSize)sizeWithText:(NSString *)text font:(UIFont *)font maxSize:(CGSize)maxSize
{
    NSDictionary *attrs = @{NSFontAttributeName : font};
    return [text boundingRectWithSize:maxSize options:NSStringDrawingUsesLineFragmentOrigin attributes:attrs context:nil].size;
}
```

### 注意要点
1. `static`修饰局部变量，可以保证局部变量只分配一次内存空间。
2. 通过代码创建初始化一个对象的时候,才会调用`- initXXX`方法，当一个对象从`xib`中创建初始化完毕的时候调用`- (void)awakeFromNib`



