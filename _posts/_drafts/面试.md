1.iOS程序的完整启动过程及原理
> 1.先执行main函数，main内部会调用UIApplicationMain函数
> 2.在UIApplicationMain函数里面创建UIApplication对象，创建UIApplication的delegate对象—–PYAppDelegate并开启一个消息循环。
> 3.为应用程序创建一个UIWindow对象（继承自UIView），设置为PYAppDelegate的window属性，创建控制器设置为UIWindow的rootViewController属性(根控制器)。展示UIWindow，展示之前会将添加rootViewController的view到UIWindow上面。

2.Category和继承的区别
Objective-C不支持多重继承，但是通过类别（Category）和协议（Protocol）可以实现代码复用和扩展。
Category，可以动态的为已经存在的类添加新的行为。
Category的使用场景：
1、当在定义类的时候，在某些情况下（例如需求变更），可能想要为其中的某个或几个类中添加方法。
2、一个类中包含了许多不同的方法需要实现，而这些方法需要不同团队的成员实现。
3、当在使用基础类库中的类时，可能希望这些类实现一些你需要的方法。

需要注意的问题：
1、Category可以访问原始类的实例变量，但不能添加变量，如果想添加变量，可以考虑通过继承创建子类。
2、Category可以重载原始类的方法，但不推荐这么做，这么做的后果是你再也不能访问原来的方法。如果确实要重载，正确的选择是创建子类。
3、和普通接口有所区别的是，在分类的实现文件中可以不必实现所有声明的方法，只要你不去调用它。

Protocol，简单来说就是一系列不属于任何类的方法列表，其中声明的方法可以被任何类实现。

3.C语言中普通变量与静态变量在内存中存储的位置，类比OC中变量
在C语言中，内存主要分为如下5个存储区：
（1）栈(Stack)：位于函数内的局部变量（包括函数实参），由编译器负责分配释放，函数结束，栈变量失效。
（2）堆(Heap)：由程序员用malloc/calloc/realloc分配，free释放。如果程序员忘记free了，则会造成内存泄露，程序结束时该片内存会由OS回收。
（3）全局区/静态区(Global Static Area)： 全局变量和静态变量存放区，程序一经编译好，该区域便存在。并且在C语言中初始化的全局变量和静态变量和未初始化的放在相邻的两个区域（在C++中，由于全局变量和静态变量编译器会给这些变量自动初始化赋值，所以没有区分了）。由于全局变量一直占据内存空间且不易维护，推荐少用。程序结束时释放。
（4）C风格字符串常量存储区： 专门存放字符串常量的地方，程序结束时释放。
（5）程序代码区：存放程序二进制代码的区域。

-----------------------

1. 基础 `@property`
- `@property` 后面可以有哪些修饰符？

> 1. 线程安全: atomic,nonatomic
2. 访问权限: readonly,readwrite
3. 内存管理(ARC): assign,strong,weak,copy   内存管理(MRC): assign,retain,copy
4. 指定方法名称: setter=,getter=

- 什么情况使用 `weak` 关键字，相比 `assign` 有什么不同？

> 1. 在ARC中,出现循环引用的时候,必须要有一端使用weak,比如:自定义View的代理属性
2. 已经自身已经对它进行一次强应用,没有必要在强引用一次,此时也会使用weak,自定义View的子控件属性一般也使用weak
3. weak当对象销毁的时候,指针会被自动设置为nil,而assign不会。assigin 可以用于非OC对象,而weak必须用于OC对象

- 怎么用 `copy` 关键字？

> 1. 对于字符串和block的属性一般使用copy
2. 字符串使用copy是为了防止外部把字符串内容改了,影响该属性
3. block使用copy是在MRC遗留下来的,在MRC中,方法内部的block是在在栈区的,使用copy可以把它放到堆区.在ACR中对于block使用copy还是strong效果是一样的

- 这个写法会出什么问题： `@property (copy) NSMutableArray *array;`

> 添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃。因为copy就是复制一个不可变NSArray的对象。

- 如何让自己的类用 `copy` 修饰符？

> 1.你是说让我的类也支持copy的功能吗? 如果面试官说是: 遵守NSCopying协议,实现 - (id)copyWithZone:(NSZone *)zone; 方法
2. 如果面试官说否,是属性中如何使用copy,在使用字符串和block的时候一般都使用copy

- 如何重写带 `copy` 关键字的 setter？

> 重写copy的setter方法时候,一定要调用一下传入的对象的copy方法,然后在赋值给该setter的方法对应的成员变量

- `@property` 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的

> 在普通的OC对象中,@property就是编译器自动帮生成一个私有的成员变量和setter与getter方法的声明和实现。为了搞清属性是怎么实现的,曾经反编译过相关的代码，大致生成了五个东西：
- OBJC_IVAR_$类名$属性名称 该属性的偏移量
- setter与getter方法对应的实现函数
- ivar_list 就是成员变量列表
- method_list 方法列表
- prop_list 属性列表
也就是说每次在增加一个属性,系统都会在ivar_list中添加一个成员变量的描述,在method_list中增加setter与getter方法的描述,在属性列表中增加一个属性的属性描述,然后计算该属性在对象中的偏移量,然后生成setter与getter方法对应的实现,在setter方法方法中从偏移量的位置开始赋值,在getter方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.

- `@protocol` 和 `category` 中如何使用 `@property`

> 1. 在protocol中使用property只会生成setter和getter方法声明,使用属性的目的,是希望遵守协议的对象的实现该属性.
2. category 使用 @property 也是只会生成setter和getter方法的声明,如果真的需要给category增加属性的实现,需要借助于运行时的两个函数 objc_setAssociatedObject  objc_getAssociatedObject

2.weak属性需要在dealloc中置nil么？

> 不需要,在ARC环境无论是强指针还是弱指针都无需在deallco设置为nil,ARC会自动帮我们处理.

3.`@synthesize`和@`dynamic`分别有什么作用？
> @property有两个对应的词，一个是@synthesize，一个是@dynamic。如果@synthesize和@dynamic都没写，那么默认的就是@syntheszie var = _var;

> @synthesize的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。

> @dynamic告诉编译器,属性的setter与getter方法由用户自己实现，不自动生成。（当然对于readonly的属性只需提供getter即可）。假如一个属性被声明为@dynamic var，然后你没有提供@setter方法和@getter方法，编译的时候没问题，但是当程序运行到instance.var =someVar，由于缺setter方法会导致程序崩溃；或者当运行到 someVar = var时，由于缺getter方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。

